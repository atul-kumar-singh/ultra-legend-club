import _get from 'lodash/get';
import _omit from 'lodash/omit';
import _has from 'lodash/has';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

export function getIndex(context) {
  return context && context.multiIndexContext ? context.multiIndexContext.targetedIndex : context.ais.mainTargetedIndex;
}

export function getResults(searchResults, context) {
  if (searchResults.results && !searchResults.results.hits) {
    return searchResults.results[getIndex(context)] ? searchResults.results[getIndex(context)] : null;
  } else {
    return searchResults.results ? searchResults.results : null;
  }
}

export function hasMultipleIndex(context) {
  return context && context.multiIndexContext;
}

// eslint-disable-next-line max-params
export function refineValue(searchState, nextRefinement, context, resetPage, namespace) {
  if (hasMultipleIndex(context)) {
    return namespace ? refineMultiIndexWithNamespace(searchState, nextRefinement, context, resetPage, namespace) : refineMultiIndex(searchState, nextRefinement, context, resetPage);
  } else {
    // When we have a multi index page with shared widgets we should also
    // reset their page to 1 if the resetPage is provided. Otherwise the
    // indices will always be reset
    // see: https://github.com/algolia/react-instantsearch/issues/310
    // see: https://github.com/algolia/react-instantsearch/issues/637
    if (searchState.indices && resetPage) {
      Object.keys(searchState.indices).forEach(function (targetedIndex) {
        searchState = refineValue(searchState, { page: 1 }, { multiIndexContext: { targetedIndex: targetedIndex } }, true, namespace);
      });
    }
    return namespace ? refineSingleIndexWithNamespace(searchState, nextRefinement, resetPage, namespace) : refineSingleIndex(searchState, nextRefinement, resetPage);
  }
}

function refineMultiIndex(searchState, nextRefinement, context, resetPage) {
  var page = resetPage ? { page: 1 } : undefined;
  var index = getIndex(context);
  var state = _has(searchState, 'indices.' + index) ? _extends({}, searchState.indices, _defineProperty({}, index, _extends({}, searchState.indices[index], nextRefinement, page))) : _extends({}, searchState.indices, _defineProperty({}, index, _extends({}, nextRefinement, page)));
  return _extends({}, searchState, { indices: state });
}

function refineSingleIndex(searchState, nextRefinement, resetPage) {
  var page = resetPage ? { page: 1 } : undefined;
  return _extends({}, searchState, nextRefinement, page);
}

// eslint-disable-next-line max-params
function refineMultiIndexWithNamespace(searchState, nextRefinement, context, resetPage, namespace) {
  var _extends4;

  var index = getIndex(context);
  var page = resetPage ? { page: 1 } : undefined;
  var state = _has(searchState, 'indices.' + index) ? _extends({}, searchState.indices, _defineProperty({}, index, _extends({}, searchState.indices[index], (_extends4 = {}, _defineProperty(_extends4, namespace, _extends({}, searchState.indices[index][namespace], nextRefinement)), _defineProperty(_extends4, 'page', 1), _extends4)))) : _extends({}, searchState.indices, _defineProperty({}, index, _extends(_defineProperty({}, namespace, nextRefinement), page)));
  return _extends({}, searchState, { indices: state });
}

function refineSingleIndexWithNamespace(searchState, nextRefinement, resetPage, namespace) {
  var page = resetPage ? { page: 1 } : undefined;
  return _extends({}, searchState, _defineProperty({}, namespace, _extends({}, searchState[namespace], nextRefinement)), page);
}

function getNamespaceAndAttributeName(id) {
  var parts = id.match(/^([^.]*)\.(.*)/);
  var namespace = parts && parts[1];
  var attributeName = parts && parts[2];

  return { namespace: namespace, attributeName: attributeName };
}

// eslint-disable-next-line max-params
export function getCurrentRefinementValue(props, searchState, context, id, defaultValue) {
  var refinementsCallback = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : function (x) {
    return x;
  };

  var index = getIndex(context);

  var _getNamespaceAndAttri = getNamespaceAndAttributeName(id),
      namespace = _getNamespaceAndAttri.namespace,
      attributeName = _getNamespaceAndAttri.attributeName;

  var refinements = hasMultipleIndex(context) && searchState.indices && namespace && searchState.indices['' + index] && _has(searchState.indices['' + index][namespace], '' + attributeName) || hasMultipleIndex(context) && searchState.indices && _has(searchState, 'indices.' + index + '.' + id) || !hasMultipleIndex(context) && namespace && _has(searchState[namespace], attributeName) || !hasMultipleIndex(context) && _has(searchState, id);
  if (refinements) {
    var currentRefinement = void 0;

    if (hasMultipleIndex(context)) {
      currentRefinement = namespace ? _get(searchState.indices['' + index][namespace], attributeName) : _get(searchState.indices[index], id);
    } else {
      currentRefinement = namespace ? _get(searchState[namespace], attributeName) : _get(searchState, id);
    }

    return refinementsCallback(currentRefinement);
  }

  if (props.defaultRefinement) {
    return props.defaultRefinement;
  }

  return defaultValue;
}

export function cleanUpValue(searchState, context, id) {
  var indexName = getIndex(context);

  var _getNamespaceAndAttri2 = getNamespaceAndAttributeName(id),
      namespace = _getNamespaceAndAttri2.namespace,
      attributeName = _getNamespaceAndAttri2.attributeName;

  if (hasMultipleIndex(context) && Boolean(searchState.indices)) {
    return cleanUpValueWithMutliIndex({
      attribute: attributeName,
      searchState: searchState,
      indexName: indexName,
      id: id,
      namespace: namespace
    });
  }

  return cleanUpValueWithSingleIndex({
    attribute: attributeName,
    searchState: searchState,
    id: id,
    namespace: namespace
  });
}

function cleanUpValueWithSingleIndex(_ref) {
  var searchState = _ref.searchState,
      id = _ref.id,
      namespace = _ref.namespace,
      attribute = _ref.attribute;

  if (namespace) {
    return _extends({}, searchState, _defineProperty({}, namespace, _omit(searchState[namespace], attribute)));
  }

  return _omit(searchState, id);
}

function cleanUpValueWithMutliIndex(_ref2) {
  var searchState = _ref2.searchState,
      indexName = _ref2.indexName,
      id = _ref2.id,
      namespace = _ref2.namespace,
      attribute = _ref2.attribute;

  var index = searchState.indices[indexName];

  if (namespace && index) {
    return _extends({}, searchState, {
      indices: _extends({}, searchState.indices, _defineProperty({}, indexName, _extends({}, index, _defineProperty({}, namespace, _omit(index[namespace], attribute)))))
    });
  }

  return _omit(searchState, 'indices.' + indexName + '.' + id);
}